---
title: "Profile vs Discrete Samples"
author: "Zachary M. Smith"
date: "7/27/2020"
output: html_document
---

```{r, echo=FALSE}
knitr::opts_chunk$set(fig.width = 8,
                      fig.height = 40)
```

# Goals

1. Join the profile data to the discrete data based on nearest depth.
2. Interpolate results to estimate a measurement at every 0.1 meter depth.

# Setup

Load the necessary R packages into the environment.
```{r, message=FALSE}
library(tidyverse)
library(here)
```

Establish dynamic file path to the R project folder.
```{r}
root_dir <- here::here()
```

# Load Data

Load in data stored as a CSV file.
```{r}
# Load profile data
profile_df <- read.csv(file = file.path(root_dir,
                                        "data",
                                        "2019_CG_EXO2_Final.csv"),
                       stringsAsFactors = FALSE)
# Load discrete data
discrete_df <- read.csv(file = file.path(root_dir,
                                         "data",
                                        "2019_CG_lab.csv"),
                       stringsAsFactors = FALSE,
                       skip = 1)
```

# Data Wrangling

Below are various steps for standardizing discrete and profile data sets. 
```{r}
# DISCRETE DATA----------------------------------------------------------------
# Keep only the rows that represent true water samples (WS). Remove QA samples.
discrete_df <- discrete_df[discrete_df$Type %in% "WS", ]
# Convert the date to a date type.
discrete_df$Date <- as.Date(discrete_df$Date, "%m/%d/%y")
# Create a unique sampling event ID
discrete_df$Event_id <- paste(discrete_df$Site,
                              discrete_df$Date,
                              sep = "_")
# Ensure that depth is numeric
discrete_df$Depth <- as.numeric(discrete_df$Depth)
# Remove unnecessary columns
discrete_df <- discrete_df[!names(discrete_df) %in% c("ID",
                                                      "Position",
                                                      "Type")]

# PROFILE DATA-----------------------------------------------------------------
# Convert the date to a date type.
profile_df$Date <- as.Date(profile_df$Date, "%m/%d/%y")
# Create a unique sampling event ID
profile_df$Event_id <- paste(profile_df$Site,
                             profile_df$Date,
                             sep = "_")
# Use "Depth" as the standard name.
profile_df$Depth <- profile_df$Depth_tenth_m
# Remove unnecessary columns.
profile_df <- profile_df[!names(profile_df) %in% c("Time",
                                                  "Depth_tenth_m",
                                                  "Depth_m")]
```

# Functions

```{r}
#' Complete the Depth Profile
#'
#' @param .x a data frame.
#' @param .depth the name of the depth column unquoted.
#' @param ... column names unquoted that will be used to 
#' aggregate (group) the data.
#'
#' @return a data frame.
#' @export

depth_complete <- function(.x, .depth, ...) {
  .x %>% 
  dplyr::group_by(...) %>% 
  tidyr::complete({{.depth}} := seq(from = 0,
                              to = max({{.depth}},
                                       na.rm = TRUE),
                              by = 0.1)) %>% 
    dplyr::ungroup()
}
```

```{r}
#' Linear Interpolate
#'
#' @param .x a vector of numeric values that will provide the increment of interpolation.
#' @param .y a vector of numeric values to be interpolated.
#' @param .quite a logical value indicating if a warning should be printed (FALSE) or not 
#' (TRUE).
#' @return a numeric vector.

interpolate <- function(.x, .y, .event, .quite = FALSE) {
  x_length <- length(.x[!is.na(.x)])
  y_length <- length(.y[!is.na(.y)])
  
  if (x_length >= 2 & y_length >= 2) {
    approx(x = .x,
           y = .y,
           xout = .x,
           method = "linear")$y
  } else {
    if (!.quite) warning(
      # When using dplyr::across() to call this function, this message is less
      # informative. It will print ".x" instead of the column name representing .y.
      paste0(unique(.event), "(", deparse(substitute(.y)),  ") \n",
             "\t One of the supplied values had less than 2 values. \n",
             "\t .x (", deparse(substitute(.x)), ") length = ", x_length, "\n",
             "\t .y (", deparse(substitute(.y)), ") length = ", y_length, "\n",
             "\t The original .y values will be returned. \n"))
    .y
  }
}
```

# Complete the Depth Profile


```{r}
# Apply depth_complete to both profile_df and discrete_df
cdepth_df <- purrr::map(list(profile_df, discrete_df), function(df_i) {
  depth_complete(.x = df_i,
                 .depth = Depth,
                 Event_id,
                 Lake,
                 Site,
                 Date)
}) %>% 
  # Join/merge the results
  # Makes a single DF containing both profile and discrete data
  purrr::reduce(.f = full_join, 
                by = c("Event_id",
                       "Lake",
                       "Site",
                       "Date",
                       "Depth")) %>% 
  # Transform the data from a wide- to long-format
  tidyr::pivot_longer(
    # Pivot by all columns except the ones listed in !all_of()
    cols = !all_of(c("Event_id",
                     "Lake",
                     "Site",
                     "Date",
                     "Depth")),
    # Column names will be placed in the "Parameter" column
    names_to = "Parameter",
    # Values from each column, corresponding with the "Parameter" column,
    # will be placed in the "Value" column
    values_to = "Value"
  )
```

# Interpolation

```{r}
interp_df <- cdepth_df %>% 
  # Aggregate the data by Event_id and Parameter
  dplyr::group_by(Event_id, Parameter) %>%
  # Order the data based on Depth
  dplyr::arrange(Event_id, Parameter, Depth) %>%
  # Apply linear interpolation
  dplyr::mutate(interp_value = interpolate(.x = Depth,
                                           .y = Value,
                                           .event = Event_id,
                                           .quite = TRUE),
                # Identify when the value is interpolated (TRUE) or not (FALSE)
                Interpolated = is.na(Value) & !is.na(interp_value)) %>% 
  # Remove the aggregation created by group_by()
  dplyr::ungroup() %>% 
  # Drop the Value column
  # No longer necessary the Interpolated (logical) column indicates which 
  # values are interpolated and which are not.
  dplyr::select(-Value) %>% 
  # Rename the interp_value column to Value
  dplyr::rename(Value = interp_value)
```

```{r, fig.width=8, fig.height=40}
#' A Facet Wrapped Plot of Parameter Depth Profile
#'
#' @param .x a data frame.
#' @param .event a string representing an event ID.
#'
#' @return a facet wrapped plot.

profile_plot <- function(.x, .event) {
  interp_sub <- interp_df %>% 
  filter(Event_id %in% .event) 
  
  interp_sub %>%
  ggplot(aes(y = Value,
             x = -Depth,
             color = Interpolated,
             fill = Interpolated,
             group = Parameter)) +
  geom_line(size = 1) +
  # geom_point() +
  theme_bw() +
  coord_flip() +
  scale_color_manual(values = c("TRUE" = "#E69F00", 
                                "FALSE" = "#56B4E9")) +
  # geom_point(data = filter(interp_sub, Interpolated == FALSE),
  #            alpha = 0.5) +
  geom_rug(data = filter(interp_sub,
                         Interpolated == FALSE,
                         !is.na(Value))) +
  facet_wrap(~Event_id + Parameter,
             scales = "free",
             ncol = 1)
}
```

```{r}

profile_plot(.x = interp_df,
             .event = .x)
```





