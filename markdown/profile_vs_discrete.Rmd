---
title: "Untitled"
author: "Zachary M. Smith"
date: "7/27/2020"
output: html_document
---

# Goals



# Setup

Load the necessary R packages into the environment.
```{r}
suppressPackageStartupMessages(
  library(dplyr)
)
```

Establish dynamic file path to the R project folder.
```{r}
root_dir <- here::here()
```

# Load Data

```{r}
# Load profile data
profile_df <- read.csv(file = file.path(root_dir,
                                        "data",
                                        "2019_CG_EXO2_Final.csv"),
                       stringsAsFactors = FALSE)
# Load discrete data
discrete_df <- read.csv(file = file.path(root_dir,
                                         "data",
                                        "2019_CG_lab.csv"),
                       stringsAsFactors = FALSE,
                       skip = 1)
```

# Data Wrangling

```{r}
# DISCRETE DATA----------------------------------------------------------------
# Keep only the rows that represent true water samples (WS). Remove QA samples.
discrete_df <- discrete_df[discrete_df$Type %in% "WS", ]
# Convert the date to a date type.
discrete_df$Date <- as.Date(discrete_df$Date, "%m/%d/%y")
# Create a unique sampling event ID
discrete_df$event_id <- paste(discrete_df$Site,
                              discrete_df$Date,
                              sep = "_")
# Ensure that depth is numeric
discrete_df$Depth <- as.numeric(discrete_df$Depth)
# PROFILE DATA-----------------------------------------------------------------
# Convert the date to a date type.
profile_df$Date <- as.Date(profile_df$Date, "%m/%d/%y")
# Create a unique sampling event ID
profile_df$event_id <- paste(profile_df$Site,
                             profile_df$Date,
                             sep = "_")
# Use "Depth" as the standard name.
profile_df$Depth <- profile_df$Depth_tenth_m
```

# Functions




```{r}
#' Complete Depth Sequence
#'
#' @param .depth_vec a vector of depth values.
#' @param .by a single numeric value representing the increment of a sequence. 
#'
#' @return a numeric vector representing a complete depth sequence.

depth_seq <- function(.depth_vec, .by = 0.1) {
  # Find the max depth to inform the seq.
  max_scalar <- max(.depth_vec,
                    na.rm = TRUE)
  # Create a sequence from 0 to the max determined above.
  seq(from = 0,
      to = max_scalar,
      by = .by)
}
```

```{r}

#' Create a Complete Depth Profile
#'
#' @param .profile_df a data frame containing profile data.
#' @param .discrete_df a data frame containing discrete data.
#' @param .depth_col the name of the Depth column in .profile_df and .discrete_df.
#' @param .quite a logical vector indicating if messages should be printed (TRUE)
#' or not (FALSE).
#' @inheritParams depth_seq
#'
#' @return a data frame with a complete depth profile.

depth_complete <- function(.profile_df, .discrete_df,
                           .depth_col = "Depth", .by = 0.1,
                           .quite) {
  # Create a DF where each row represents a depth at a specified interval.
  depth_df <- data.frame(
    # .profile_df is used because it most likely contains the deepest depth
    # observed between the two DFs.
    depth_seq(.depth_vec = .profile_df[.depth_col],
              .by = .by)
  )
  # Rename the depth column based on the supplied .depth_col.
  names(depth_df) <- .depth_col
  # Identify which column names are shared between the two DFs. 
  # Will be used to merge by.
  shared_names <- names(.profile_df)[names(.profile_df) %in% names(.discrete_df)]
  
  data.frame(unique(.profile_df[shared_names]))
  # Join the profile DF with the new Depth DF to create a complete
  # depth profile.
  pro_depth_df <- merge(x = .profile_df,
                  y = depth_df,
                  by = .depth_col,
                  all = TRUE)
  
  # Indicate which column names will be used to merge the DFs.
  if (.quite != TRUE) message("Merging by: ", paste(shared_names, collapse = ", "))
  # Join the discrete DF with the complete depth profile DF 
  # using the shared names vector.
  final_df <- merge(x = .discrete_df,
                    y = pro_depth_df,
                    by = shared_names,
                    all = TRUE)
  # Arrange the DF rows based on the depth.
  final_df <- final_df[order(final_df$Depth), ]
  # Return a DF.
  return(final_df)
}
```


```{r}
depth_complete <- function(.x, .depth, ...) {
  .x %>% 
  dplyr::group_by(...) %>% 
  tidyr::complete({{.depth}} := seq(from = 0,
                              to = max({{.depth}}, na.rm = TRUE),
                              by = 0.1)) %>% 
    dplyr::ungroup()
}


cdepth_df <- purrr::map(list(profile_df, discrete_df), function(df_i) {
  depth_complete(.x = df_i,
                 .depth = Depth,
                 event_id,
                 Lake,
                 Site,
                 Date)
}) %>% 
  purrr::reduce(.f = full_join)


test <- cdepth_df %>% 
  # filter(event_id %in% "CGLT(1)_2019-05-08") %>% 
  group_by(event_id) %>%
    arrange(Depth) %>%
      mutate(ip.value = approx(x = Depth,
                               y = pH,
                               xout = Depth)$y) 

```

```{r}
event_vec <- unique(c(.profile_df$event_id,
                      .discrete_df$event_id))

comp_depth_list <- lapply(event_vec, function(event_i) {
  depth_complete(.profile_df = profile_df[profile_df$event_id %in% event_i, ],
                 .discrete_df = discrete_df[discrete_df$event_id %in% event_i, ],
                 .depth_col = "Depth",
                 .by = 0.1,
                 .quite = TRUE)
})

comp_depth_df <- do.call(rbind, comp_depth_list)

```


# Interpolation



```{r}
depth_df <- data.frame(
  Depth = complete_depth(.depth_vec = prof)
)
```


